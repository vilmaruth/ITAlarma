
<!-- saved from url=(0054)http://robots-argentina.com.ar/Comunicacion_busI2C.htm -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><script language="JavaScript"><!-- 
if ( document.domain == "rob.axxon.com.ar" ) { top.location.href="http://robots-argentina.com.ar/Comunicacion_busI2C.htm"; } 
--></script>



<title>Comunicación - Bus I2C - Robots Argentina</title>
<meta name="keywords" content="Robotics, Robotica, Electronics, Electronica, 
Robot, Microcontrollers, Microcontroladoe, PIC, Automation, Automatizacion, 
Circuitos, Circuits, Comunicación, bus, I2C">
<style type="text/css"><!--  
     a:active {  font-family: Verdana; font-size: 10pt; font-style: normal; font-weight: bold; font-variant: normal; text-transform: none; color: #0000FF; text-decoration: none}
     a:hover {  font-family: Verdana; font-size: 10pt; font-style: normal; font-weight: bold; font-variant: normal; text-transform: none; color: #FF0000; text-decoration: none}
     a:link {  font-family: Verdana; font-size: 10pt; font-style: normal; font-weight: bold; font-variant: normal; text-transform: none; color: #0000c0; text-decoration: none}
     a:visited {  font-family: Verdana; font-size: 10pt; font-style: normal; font-weight: bold; font-variant: normal; text-transform: none; color: #800080; text-decoration: none}
   --></style>
<link rel="stylesheet" type="text/css" href="./Comunicación - Bus I2C - Robots Argentina_files/d.css">
<link rel="stylesheet" type="text/css" href="./Comunicación - Bus I2C - Robots Argentina_files/robots.css">
<script type="text/javascript" src="./Comunicación - Bus I2C - Robots Argentina_files/dict2.js" language="javascript"></script><style type="text/css" style="display: none !important;">object:not([type]),object[classid$=":D27CDB6E-AE6D-11cf-96B8-444553540000"],object[classid$=":d27cdb6e-ae6d-11cf-96b8-444553540000"],object[codebase*="swflash.cab"],object[data*=".swf"],embed[type="application/x-shockwave-flash"],embed[src*=".swf"],object[type="application/x-shockwave-flash"],object[src*=".swf"],object[codetype="application/x-shockwave-flash"],iframe[type="application/x-shockwave-flash"],object[classid$=":166B1BCA-3F9C-11CF-8075-444553540000"],object[codebase*="sw.cab"],object[data*=".dcr"],embed[type="application/x-director"],embed[src*=".dcr"],object[type="application/x-director"],object[src*=".dcr"],object[classid$=":15B782AF-55D8-11D1-B477-006097098764"],object[codebase*="awswaxf.cab"],object[data*=".aam"],embed[type="application/x-authorware-map"],embed[src*=".aam"],object[type="application/x-authorware-map"],object[src*=".aam"],object[classid*="32C73088-76AE-40F7-AC40-81F62CB2C1DA"],object[type="application/ag-plugin"],object[type="application/x-silverlight"],object[type="application/x-silverlight-2"],object[source*=".xaml"],object[sourceelement*="xaml"],embed[type="application/ag-plugin"],embed[source*=".xaml"]{display: none !important;}</style><style type="text/css"></style>
</head>

<body bgcolor="#f0f0e0" text="#000000" xxlink="#e0e0ff" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">

<!--tabla titulo-->
<div align="center"><center>
<table align="center" width="750" border="0" cellspacing="0" cellpadding="0">
<tbody><tr>
<td align="center" height="80" width="50%" bgcolor="#339966" background="./Comunicación - Bus I2C - Robots Argentina_files/robots-fondo001.jpg"><img src="./Comunicación - Bus I2C - Robots Argentina_files/robots-enc.gif" width="236" height="84">
</td>
<td align="center" height="80" width="50%" bgcolor="#339966" background="./Comunicación - Bus I2C - Robots Argentina_files/robots-fondo001.jpg"><a href="http://robots-argentina.com.ar/robots.htm"><img src="./Comunicación - Bus I2C - Robots Argentina_files/robots-logo003.gif" border="0"></a><br>
<font face="Courier New" size="3" color="#ffffff"><b>pasión por la robótica en Argentina</b></font></td>
</tr>
</tbody></table>
<center><script type="text/javascript"><!--
google_ad_client = "pub-7090242166042605";
/* 728x90, creado 16/03/10 */
google_ad_slot = "6066685945";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript" src="./Comunicación - Bus I2C - Robots Argentina_files/show_ads.js">
</script></center>
<table align="center" width="750" border="0" cellspacing="0" cellpadding="0">
<tbody><tr>
<td align="center">
    <font face="Verdana, Helvetica, Arial" size="1" color="#a0a0ff"><b>
    [<a href="http://robots-argentina.com.ar/robots.htm">PRINCIPAL</a>]
    [<a href="http://robots-argentina.com.ar/robots-nos.htm">NOSOTROS</a>] 
    [<a href="http://robots-argentina.com.ar/robots-act.htm">ACTIVIDAD</a>] 
    [<a href="http://robots-argentina.com.ar/robots-not.htm">NOTICIAS</a>] 
    [<a href="http://robots-argentina.com.ar/robots-art.htm">ARTICULOS</a>] 
    [<a href="http://robots-argentina.com.ar/robots-gal.htm">GALERIA</a>] 
    [<a href="http://robots-argentina.com.ar/robots-enlaces.htm">ENLACES</a>] 
    [<a href="mailto:ecarletti@speedy.com.ar" target="_blank">CONTACTO</a>]
 </b></font>
</td>
</tr>
</tbody></table>

<center><div align="center">
<table cellspacing="0" cellpadding="0" border="0"><tbody><tr><td height="8"></td></tr></tbody></table>
<font face="Arial">
</font><form method="get" action="http://ar.groups.yahoo.com/subscribe/robots_desarrolladores"><font face="Arial">
<table width="460" cellspacing="0" cellpadding="1" border="0" bgcolor="#ffffcc">
  <tbody><tr>
    <td colspan="2" align="center">
      <font face="Verdana" style="font-size: 11px"><b><font color="darkred">Desarrolladores de Robots</font>:<br> Un grupo donde podemos conversar de los temas que nos interesan</b><br>
	<table cellspacing="0" cellpadding="0" border="0"><tbody><tr><td height="4"></td></tr></tbody></table>
      <input type="text" name="user" value="Ingresa tu dirección de correo electrónico y pulsa enter" size="60">
    </font></td>
  </tr>
  <tr align="center">
    <td colspan="3"><font face="Verdana" size="1"><b>Desarrolladores de Robots</b> funciona en Grupos Yahoo! <a href="http://ar.groups.yahoo.com/">ar.groups.yahoo.com</a>
    </font></td>
  </tr>
</tbody></table></font></form></div></center></center></div>

<!--tabla titulo-->

<center><div align="center">
<table width="80%">
<tbody><tr>
<td>
<center>
<font face="Verdana, Arial, Helvetica" size="2"><h2>Comunicación - Bus I2C<br>
<small>Descripción y funcionamiento<br>por <b>Eduardo J. Carletti</b></small></h2>
</font></center><font face="Verdana, Arial, Helvetica" size="2">

<b></b><p><b><font size="4">Introducción</font></b></p>

<table width="210" cellspacing="0" cellpadding="8" align="right">
<tbody><tr>
<td width="5"> </td>
<td bgcolor="#ffffff">
<font face="Verdana" size="1">
<b>DEFINICIÓN DE I2C (I<sup><small>2</small></sup>C):</b><br>
Abreviatura de Inter-IC (inter integrated circuits), un tipo de bus diseñado por Philips Semiconductors 
a principios de los 80s, que se utiliza para conectar circuitos integrados (ICs). El I2C es un bus con 
múltiples maestros, lo que significa que se pueden conectar varios chips al mismo bus y que todos ellos 
pueden actuar como maestro, sólo con iniciar la transferencia de datos. Este bus se utiliza en muchos 
dispositivos, en especial en equipos de vídeo como monitores de computadora, televisores y videocaseteras.
</font></td>
</tr>
</tbody></table>
<p align="justify">
El <b>bus I2C</b>, un estándar que facilita la comunicación entre microcontroladores, memorias 
y otros dispositivos con cierto nivel de "inteligencia", sólo requiere de dos líneas de señal 
y un común o masa. Fue diseñado a este efecto por Philips y permite el intercambio de información 
entre muchos dispositivos a una velocidad aceptable, de unos 100 Kbits por segundo, aunque hay 
casos especiales en los que el reloj llega hasta los 3,4 MHz.</p>

<p align="justify">
La metodología de comunicación de datos del bus I2C es en serie y sincrónica. Una de las señales del 
bus marca el tiempo (pulsos de reloj) y la otra se utiliza para intercambiar datos.</p>

<p><b>Descripción de las señales</b></p>

<ul><ul>
<li><b>SCL</b> (System Clock) es la línea de los pulsos de reloj que sincronizan el sistema.
</li><li><b>SDA</b> (System Data) es la línea por la que se mueven los datos entre los dispositivos.
</li><li><b>GND</b> (Masa) común de la interconección entre todos los dispositivos "enganchados" al bus. 
</li></ul></ul>

<p align="justify">
Las líneas <b>SDA</b> y <b>SCL</b> son del tipo drenaje abierto, es decir, un estado similar al de 
colector abierto, pero asociadas a un transistor de efecto de campo (o FET). Se deben 
polarizar en estado alto (conectando a la alimentación por medio de resistores "pull-up") 
lo que define una estructura de bus que permite conectar en paralelo múltiples entradas 
y salidas.</p>

<center><img src="./Comunicación - Bus I2C - Robots Argentina_files/Comunicacion_busI2Cblk.gif" width="539" height="158"></center>

<p align="justify">
El diagrama es suficientemente autoexplicativo. Las dos líneas del bus están en un 
nivel lógico alto cuando están inactivas. En principio, el número de dispositivos 
que se puede conectar al bus no tiene límites, aunque hay que observar que la capacidad 
máxima sumada de todos los dispositivos no supere los 400 pF. El valor de los resistores 
de polarización no es muy crítico, y puede ir desde 1K8 (1.800 ohms) a 47K (47.000 ohms). 
Un valor menor de resistencia incrementa el consumo de los integrados pero disminuye 
la sensibilidad al ruido y mejora el tiempo de los flancos de subida y bajada de las 
señales. Los valores más comunes en uso son entre 1K8 y 10K.</p>

<p><b>Protocolo de comunicación del bus I2C</b></p>

<p align="justify">
Habiendo varios dispositivos conectados sobre el bus, es lógico que para establecer 
una comunicación a través de él se deba respetar un protocolo. Digamos, en primer 
lugar, lo más importante: existen dispositivos <b>maestros</b> y dispositivos 
<b>esclavos</b>. Sólo los dispositivos maestros pueden iniciar una comunicación.</p>

<p align="justify"><img src="./Comunicación - Bus I2C - Robots Argentina_files/Comunicacion_busI2Cinicio.gif" width="203" height="147" align="right" hspace="15">
La condición inicial, de <b>bus libre</b>, es cuando ambas señales están en estado lógico 
alto. En este estado cualquier dispositivo maestro puede ocuparlo, estableciendo 
la condición de <b>inicio</b> (start). Esta condición se presenta cuando un dispositivo 
maestro pone en estado bajo la línea de datos (SDA), pero dejando en alto la línea de 
reloj (SCL).</p>

<p align="justify">
El primer byte que se transmite luego de la condición de inicio contiene siete bits 
que componen la dirección del dispositivo que se desea seleccionar, y un octavo bit 
que corresponde a la operación que se quiere realizar con él (lectura o escritura).</p>

<p align="justify">
Si el dispositivo cuya dirección corresponde a la que se indica en los siete bits (A0-A6) 
está presente en el bus, éste contesta con un bit en bajo, ubicado inmediatamente luego del 
octavo bit que ha enviado el dispositivo maestro. Este bit de <b>reconocimiento</b> (ACK) en bajo 
le indica al dispositivo maestro que el esclavo <b>reconoce</b> la solicitud y está en condiciones 
de comunicarse. Aquí la comunicación se establece en firme y comienza el intercambio 
de información entre los dispositivos.</p>

<center><img src="./Comunicación - Bus I2C - Robots Argentina_files/Comunicacion_busI2Cack.gif" width="364" height="57"></center>

<p align="justify">
Si el bit de <b>lectura/escritura</b> (R/W) fue puesto en esta comunicación a 
nivel lógico bajo (escritura), el dispositivo maestro envía datos al dispositivo 
esclavo. Esto se mantiene mientras continúe recibiendo señales de reconocimiento, 
y el contacto concluye cuando se hayan transmitido todos los datos.</p>

<p align="justify"><img src="./Comunicación - Bus I2C - Robots Argentina_files/Comunicacion_busI2Cparada.gif" width="203" height="147" align="left" hspace="15">
En el caso contrario, cuando el bit de lectura/escritura estaba a nivel lógico 
alto (lectura), el dispositivo maestro genera pulsos de reloj para que el dispositivo 
esclavo pueda enviar los datos. Luego de cada byte recibido el dispositivo maestro 
(quien está recibiendo los datos) genera un pulso de <b>reconocimiento</b>.</p>

<p align="justify">
El dispositivo maestro puede dejar libre el bus generando una condición de <b>parada</b> 
(o detención; stop en inglés).</p>

<p align="justify">
Si se desea seguir transmitiendo, el dispositivo maestro puede generar otra condición de 
inicio en lugar de una condición de parada. Esta nueva condición de inicio se denomina "inicio 
reiterado" y se puede emplear para direccionar un dispositivo esclavo diferente o para 
alterar el estado del bit de lectura/escritura.</p>

<br>
<p><b>Definición de términos:</b></p>

<div align="justify">
<ul>
<li><b>Maestro</b> (Master): Dispositivo que determina los tiempos y la dirección del tráfico en el bus. Es el único que aplica los pulsos de reloj en la línea SCL. Cuando se conectan varios dispositivos maestros a un mismo bus la configuración obtenida se denomina "multi-maestro".
</li><li><b>Esclavo</b> (Slave): Todo dispositivo conectado al bus que no tiene la capacidad de generar pulsos de reloj. Los dispositivos esclavos reciben señales de comando y de reloj generados desde el maestro.
</li><li><b>Bus libre</b> (Bus Free): Estado en el que ambas líneas (SDA y SCL) están inactivas, presentando un estado lógico alto. Es el único momento en que un dispositivo maestro puede comenzar a hacer uso del bus.
</li><li><b>Comienzo</b> (Start): Se produce cuando un dispositivo maestro ocupa el bus, generando la condición. La línea de datos (SDA) toma un estado bajo mientras que la línea de reloj (SCL) permanece alta.
</li><li><b>Parada</b> (Stop): Un dispositivo maestro puede generar esta condición, dejando libre el bus. La línea de datos y la de reloj toman un estado lógico alto.
</li><li><b>Dato válido</b> (Valid Data): Situación presente cuando un dato presente en la línea SDA es estable al tiempo que la línea SCL está a nivel lógico alto.
</li><li><b>Formato de Datos</b> (Data Format): La transmisión de un dato a través de este bus consiste de 8 bits de dato (1 byte). A cada byte transmitido al bus le sigue un noveno pulso de reloj durante el cual el dispositivo receptor del byte debe generar un pulso de reconocimiento.
</li><li><b>Reconocimiento</b> (Acknowledge): El pulso de reconocimiento, conocido como ACK (del inglés Acknowledge), se logra colocando la línea de datos a un nivel lógico bajo durante el transcurso del noveno pulso de reloj.
</li><li><b>Dirección</b> (Address): Todo dispositivo diseñado para funcionar en este bus posee su propia y única dirección de acceso, preestablecida por el fabricante. Hay dispositivos que permiten definir externamente parte de la dirección de acceso, lo que habilita que se pueda conectar en un mismo bus un conjunto de dispositivos del mismo tipo, sin problemas de identificación. La dirección 00 es la denominada "de acceso general"; a ésta responden todos los dispositivos conectados al bus.
</li><li><b>Lectura/Escritura</b> (Bit R/W): Cada dispositivo tiene una dirección de 7 bits. El octavo bit (el menos significativo) que se envía durante la operación de direccionamiento, completando el byte, indica el tipo de operación a realizar. Si este bit es alto el dispositivo maestro lee información proveniente de un dispositivo esclavo. Si este bit es bajo, el dispositivo maestro escribe información en un dispositivo esclavo. 
</li></ul>
</div>
<br>

<p><b>La comunicación en más detalle</b></p>

<p align="justify">
Cuando el dispositivo maestro quiere comunicarse con un esclavo, produce una secuencia de inicio en el 
bus. La secuencia de inicio es una de las dos secuencias especiales que se han definido en el bus I2C; 
la otra es la secuencia de parada. Las secuencias de inicio y la de parada son especiales 
porque son los dos únicos casos en que se permite que la línea de datos (SDA) cambie cuando la 
línea de reloj (SCL) está alta. Cuando se están transmitiendo datos, la línea SDA debe permanecer 
estable, y jamás cambiar, mientras la línea SCL está alta. Las secuencias de inicio y de parada 
señalan el comienzo y el final de una transacción con los dispositivos esclavos.</p>

<p align="justify">
Los datos se transfieren en secuencias de 8 bits. Estos bits se colocan en la línea SDA comenzando 
por el bit de más peso (o más significativo). Una vez puesto un bit en SDA, se lleva la línea SCL a 
alto. Debemos recordar que el chip no puede llevar la línea a un estado alto, en realidad, lo que 
hace es "soltarla", y el que la pone en nivel lógico alto es el resistor de polarización. Por cada 
8 bits que se transfieren, el dispositivo que recibe el dato envía de regreso un bit de reconocimiento, 
de modo que en realidad por cada byte de dato se producen 9 pulsos sobre la línea SCL (es decir, 9 pulsos 
de reloj por cada 8 bits de dato). Si el dispositivo que recibe envía un bit de reconocimiento bajo, indica 
que ha recibido el dato y que está listo para aceptar otro byte. Si retorna un alto, lo que indica 
es que no puede recibir más datos y el dispositivo maestro debería terminar la transferencia enviando 
una secuencia de parada.</p>

<p><b>Direccionamiento de dispositivos en el bus I2C</b></p>

<p align="justify">
Lo más común en los dispositivos para el bus I2C es que utilicen direcciones de 7 bits, aunque existen 
dispositivos de 10 bits. Este último caso es raro.</p>

<p align="justify">
Una dirección de 7 bits implica que se pueden poner hasta 128 dispositivos sobre un bus I2C, ya 
que un número de 7 bits puede ir desde 0 a 127. Cuando se envían las direcciones de 7 bit, de cualquier 
modo la transmisión es de 8 bits. El bit extra se utiliza para informarle al dispositivo esclavo si 
el dispositivo maestro va a escribir o va a leer datos desde él. Si el bit de lectura/escritura (R/W) 
es cero, el dispositivo maestro está escribiendo en el esclavo. Si el bit es 1 el maestro está leyendo 
desde el esclavo. La dirección de 7 bit se coloca en los 7 bist más significativos del byte y el 
bit de lectura/escritura es el bit menos significativo.</p>

<p align="justify">
El hecho de colocar la dirección de 7 bits en los 7 bits más significativos del byte produce 
confusiones entre quienes comienzan a trabajar con este bus. Si, por ejemplo, se desea escribir en 
la dirección 21 (hexadecimal), en realidad se debe enviar un 42, que es un 21 desplazado un bit hacia arriba. 
También se pueden tomar las direcciones del bus I2C como direcciones de 8 bit, 
en las que las pares son de sólo escritura y las impares son de sólo lectura. Para dar un ejemplo, 
el integrado de brújula magnética <a href="http://robots-argentina.com.ar/Sensores_magnetismo.htm#CMPS03">CMPS03</a> es fijado en 
fábrica en la dirección 0xC0 ($C0). La dirección 0xC0 se utiliza para escribir en él y la dirección 
0xC1 es para leer de él.</p>

<p><b>Protocolo de programación para el bus I2C</b></p>

<p align="justify">
Lo primero que ocurre en un bus I2C es que el dispositivo maestro envía una secuencia de inicio. 
Esto alerta a los dispositivos esclavos, poniéndolos a la espera de una transacción. Éstos quedan 
atentos para ver si se trata de una solicitud para ellos. A continuación el dispositivo maestro 
envía la dirección de dispositivo. El dispositivo esclavo que posee esa dirección continuará 
con la transacción, y los otros ignorarán el resto de los intercambios, esperando la próxima 
secuencia de inicio.
</p>

<p align="justify">
Habiendo direccionado ya el dispositivo esclavo, lo que debe hacer ahora el maestro es enviar la 
ubicación interna o número de registro desde el que desea leer o al que va a escribir. La cantidad 
depende, obviamente, de qué dispositivo es y de cuántos registros internos posee. Algunos dispositivos 
muy simples no tienen ninguno, pero la mayoría sí los poseen.</p>

<p align="justify">
Siguiendo con el ejemplo del <a href="http://robots-argentina.com.ar/Sensores_magnetismo.htm#CMPS03">CMPS03</a>, éste posee 16 
ubicaciones internas, numeradas desde el 0 al 15. Otro dispositivo, el medidor ultrasónico 
de distancia <a href="http://robots-argentina.com.ar/Sensores_rangers.htm#SRF08">SRF08</a>, tiene 36 registros.</p>

<p align="justify">
Una vez que el maestro ha enviado la dirección del dispositivo en el bus I2C y la dirección del 
registro interno del dispositivo, puede enviar ahora el byte o bytes de datos. El dispositivo maestro 
puede seguir enviando bytes al esclavo, que normalmente serán puestos en registros con direcciones 
sucesivas, ya que el esclavo incrementa automáticamente la dirección del registro interno después 
de recibir cada byte. Cuando el maestro ha terminado de escribir datos en el esclavo, envía una 
secuencia de parada que concluye la transacción.</p>

<p><b>Escritura en un dispositivo esclavo:</b>
</p><ul>
<li>1. Enviar una secuencia de inicio
</li><li>2. Enviar la dirección de dispositivo con el bit de lectura/escritura en bajo
</li><li>3. Enviar el número de registro interno en el que se desea escribir
</li><li>4. Enviar el byte de dato
</li><li>5. [Opcionalmente, enviar más bytes de dato]
</li><li>6. Enviar la secuencia de parada</li></ul><p></p>

<p align="justify">Como ejemplo, veamos un SRF08, que tiene una dirección de bus fijada en fábrica 
de 0xE0. Para comenzar una medición de distancia con el SRF08 se debe escribir 0x51 en el registro 
de comando, ubicado en la dirección interna 0x00. La secuencia es la que sigue:</p>
<ul>
<li>1. Enviar una secuencia de inicio
</li><li>2. Enviar 0xE0 (La dirección de dispositivo del SRF08 con el bit de lectura/escritura en bajo)
</li><li>3. Enviar 0x00 (dirección interna del registro de comando)
</li><li>4. Enviar 0x51 (el comando para comenzar la medición del SRF08)
</li><li>5. Enviar la secuencia de parada</li></ul><p></p>

<p><b>Lectura desde un dispositivo esclavo:</b>

</p><p align="justify">Esta operación es algo más complicada, pero no demasiado. Antes de leer datos 
desde el dispositivo esclavo, primero se le debe informar desde cuál de sus direcciones internas 
se va a leer. De manera que una lectura desde un dispositivo esclavo en realidad comienza con 
una operación de escritura en él. Es igual a cuando se desea escribir en él: Se envía la secuencia 
de inicio, la dirección de dispositivo con el bit de lectura/escritura en bajo y el registro 
interno desde el que se desea leer. Ahora se envía otra secuencia de inicio nuevamente con la 
dirección de dispositivo, pero esta vez con el bit de lectura/escritura en alto. Luego se leen todos los bytes 
necesarios y se termina la transacción con una secuencia de parada.</p>

<p align="justify">Volviendo al ejemplo del módulo de brújula CMPS03, veamos cómo se lee el registro de ángulo:</p>
<ul>
<li>1. Enviar una secuencia de inicio
</li><li>2. Enviar 0xC0 (La dirección de dispositivo del CMPS03 con el bit de lectura/escritura en bajo)
</li><li>3. Enviar 0x01 (dirección interna del registro de ángulo en valor 0-255)
</li><li>4. Enviar una secuencia de inicio (inicio reiterado)
</li><li>5. Enviar 0xC1 (La dirección de dispositivo del CMPS03 con el bit de lectura/escritura en alto)
</li><li>6. Leer un byte de dato desde el CMPS03
</li><li>7. Enviar la secuencia de parada</li></ul><p></p>

<p>La secuencia se verá así:</p>

<center><img src="./Comunicación - Bus I2C - Robots Argentina_files/Comunicacion_busI2Clectura.gif" width="600" height="193"></center>

<p><b>Un caso un poco más complicado</b></p>

<p align="justify">
Esto es todo cuando se trata de comunicaciones simples, pero debemos considerar una posible complicación:
Cuando el dispositivo maestro está leyendo desde el esclavo, quien pone los datos en la línea SDA del bus 
es el dispositivo esclavo, y el maestro es el que controla el pulso de reloj. ¿Qué pasa si el esclavo 
no está listo para enviar un dato?
Con dispositivos como una EEPROMs esto no sería problema, pero si el dispositivo esclavo es un 
microprocesador, que tiene otras tareas que realizar, pueden surgir inconvenientes.</p>

<p align="justify">
Para atender la transacción, el microprocesador debe pasar a una rutina de interrupción, guardar sus 
registros de trabajo, determinar qué dirección desea leer el dispositivo maestro, obtener el dato y 
ponerlo en su registro de transmisión. Esto puede llevar varios microsegundos, lo que implica que el 
dispositivo maestro podría estar enviando pulsos de reloj ciegamente por la línea SCL sin que el 
dispositivo esclavo pueda responderle. El protocolo I2C ofrece una solución para esto: el esclavo puede 
mantener la línea SCL en bajo. A esto se le llama estiramiento del reloj. Cuando el esclavo recibe el 
comando de lectura lo primero que hace es poner la línea de reloj en bajo. Entonces sí, obtiene el dato 
solicitado, lo pone en el registro de transmisión, y recién entonces libera la línea de reloj, que 
pasará de inmediato a alto debido al nivel que aporta el resistor de polarización.</p>

<p align="justify">
Desde el punto de vista del dispositivo maestro, éste tratará de enviar el primer pulso de reloj para la 
lectura de datos liberando la línea SCL para que pase a alto, pero antes de continuar comprobará que 
ésta realmente haya ido al nivel lógico 1. Si la línea SCL permanece en bajo, el dispositivo maestro 
interpreta que el esclavo la mantiene así y espera a que SCL vaya a alto antes de continuar. Por suerte, 
la mayoría de los puertos I2C de los microprocesadores manejan esto de manera automática.</p>

<p align="justify">
Sin embargo, a veces el manejo de I2C en el dispositivo maestro no está implementado por circuito, sino 
que es un juego de subrutinas que maneja dos líneas de un puerto. 
Algunas implementaciones ignoran este estiramiento del reloj. Estas soluciones trabajarán bien con 
dispositivos tales como las EEPROM, pero no podrán intercambiar datos correctamente con microprocesadores 
esclavos que utilizan el estiramiento del pulso de reloj. Como resultado, se obtendrán datos erróneos.</p>

<p><a href="http://www.semiconductors.philips.com/acrobat_download/literature/9398/39340011.pdf" target="_blank"><small><u>Especificaciones de Philips sobre el bus I2C (PDF)</u></small></a>

</p></font></td>
</tr>
</tbody></table>
<br>
</div></center>

<!--pie pagina-->
<div align="center"><center>
<table align="center" width="750" border="0" cellspacing="0" cellpadding="0">
<tbody><tr>
<td align="center">
<font face="Verdana, Helvetica, Arial" size="1"><b>© 2007, 2012 Robots Argentina</b><br>
© 2012</font></td>
</tr>


</tbody></table>
</center></div>
<center>
<table width="640">
<tbody><tr>
<td>
<script type="text/javascript"><!--
google_ad_client = "ca-pub-7090242166042605";
/* Abajo_Cuentos300x250 */
google_ad_slot = "7801325420";
google_ad_width = 300;
google_ad_height = 250;
//-->
</script>
<script type="text/javascript" src="./Comunicación - Bus I2C - Robots Argentina_files/show_ads.js">
</script>
</td>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>
<script type="text/javascript"><!--
google_ad_client = "ca-pub-7090242166042605";
/* Abajo_Cuentos300x250 */
google_ad_slot = "7801325420";
google_ad_width = 300;
google_ad_height = 250;
//-->
</script>
<script type="text/javascript" src="./Comunicación - Bus I2C - Robots Argentina_files/show_ads.js">
</script>
</td>
</tr></tbody></table>
<br>

<!--pie pagina-->




</center></body></html>